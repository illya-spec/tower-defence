<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="UTF-8">
<title>Tower Defense</title>
<style>
/* –û–°–ù–û–í–ù–Ü –°–¢–ò–õ–Ü */
body { 
    background: #222; 
    color: #fff;      
    font-family: Arial; 
    text-align: center; 
}
canvas { 
    background: #333; 
    display: block; 
    margin: 10px auto; 
    border: 2px solid #555; 
}
button, select { 
    padding: 10px 20px; 
    font-size: 16px; 
    cursor: pointer; 
    margin: 5px; 
}
#advanceWave:disabled {
    background-color: #3e2723 !important; /* –¢–µ–º–Ω—ñ—à–∏–π –∫–æ–ª—ñ—Ä –¥–ª—è –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–æ—ó –∫–Ω–æ–ø–∫–∏ */
    cursor: not-allowed;
}
</style>
</head>
<body>

<h1>üõ° Tower Defense</h1>
<p>
¬† –ú–æ–Ω–µ—Ç–∏: <span id="coins">100</span> |
¬† –•–≤–∏–ª—è: <span id="wave">0</span>/10
</p>

<select id="modeSelect">
¬† <option value="normal">–ó–≤–∏—á–∞–π–Ω–∏–π —Ä–µ–∂–∏–º</option>
¬† <option value="hard">–í–∞–∂–∫–∏–π —Ä–µ–∂–∏–º</option>
</select>

<button id="startGame">‚ñ∂ –ü–æ—á–∞—Ç–∏ –≥—Ä—É</button>
<button id="restartGame">‚ü≥ –†–µ—Å—Ç–∞—Ä—Ç</button>
<button id="advanceWave" style="background-color: darkgoldenrod; color: white;">‚ñ∂‚ñ∂ –ù–∞—Å—Ç—É–ø–Ω–∞ —Ö–≤–∏–ª—è</button>

<button id="buyTower">–ö—É–ø–∏—Ç–∏ –≤–µ–∂—É (50)</button>
<button id="buySniperTower">–ö—É–ø–∏—Ç–∏ –°–Ω–∞–π–ø–µ—Ä—Å—å–∫—É –≤–µ–∂—É (100)</button>
<button id="buyBarricade">üöß –ö—É–ø–∏—Ç–∏ –ë–∞—Ä–∏–∫–∞–¥—É (75)</button>

<canvas id="game" width="600" height="400"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const advanceWaveButton = document.getElementById("advanceWave");

let coins = 100;
let wave = 0; 
let currentWaveIndex = 0; 
let baseHP = 100;
let gameStarted = false;
let buyingTower = false;
let buyingSniper = false;
let buyingBarricade = false;

// –ù–û–í–ò–ô –ü–†–ê–ü–û–†–ï–¶–¨: –ë–ª–æ–∫—É—î –±–∞–≥–∞—Ç–æ—Ä–∞–∑–æ–≤–∏–π –∑–∞–ø—É—Å–∫ —Ñ—É–Ω–∫—Ü—ñ—ó spawnWave
let isSpawning = false; 

// –ó–ú–Ü–ù–ù–Ü –î–õ–Ø –í–ò–î–Ü–õ–ï–ù–ù–Ø –¢–ê –ö–ï–†–£–í–ê–ù–ù–Ø
let selectedTower = null;
let hoveredTower = null;
let selectedBarricade = null;
let hoveredBarricade = null;

// –ö–û–ù–°–¢–ê–ù–¢–ò –ö–ï–†–£–í–ê–ù–ù–Ø
const BUTTON_SIZE = 20;
const BUTTON_OFFSET_Y = -15; 
const BUTTON_UPGRADE_OFFSET_X = -25;
const BUTTON_SELL_OFFSET_X = 25;
const BUTTON_HEAL_OFFSET_X = 0; 

const towers = [];
const snipers = [];
const enemies = [];
const bullets = [];
const bosses = [];
const barricades = [];

// –•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –ë–∞—Ä–∏–∫–∞–¥
const BARRICADE_MAX_HP = { 1: 100, 2: 120, 3: 150 };
const BARRICADE_COST = 75;
const BARRICADE_UPGRADE_COST = 50;
const BARRICADE_HEAL_COST = 10; 

const path = [
¬† {x:0, y:60},{x:200, y:60},{x:200, y:200},{x:80, y:200},
¬† {x:80, y:350},{x:350, y:350},{x:350, y:120},{x:520, y:120},
¬† {x:520, y:300},{x:600, y:300}
];
const pathWidth = 40;

let mode = "normal";
document.getElementById("modeSelect").onchange = () => {
¬† mode = document.getElementById("modeSelect").value;
};

// --- –§–£–ù–ö–¶–Ü–á –ë–ê–†–ò–ö–ê–î/–í–ï–ñ (–ë–µ–∑ –∑–º—ñ–Ω) ---
function createBarricade(x, y) {
    return { x, y, hp: BARRICADE_MAX_HP[1], maxHp: BARRICADE_MAX_HP[1], level: 1 };
}
function getBarricadeUpgradeCost(barricade) {
    return (barricade.level < 3) ? BARRICADE_UPGRADE_COST : null;
}
function upgradeBarricade(barricade) {
    const cost = getBarricadeUpgradeCost(barricade);
    if (!cost || coins < cost) return false;
    coins -= cost;
    barricade.level++;
    barricade.maxHp = BARRICADE_MAX_HP[barricade.level];
    barricade.hp = barricade.maxHp; 
    return true;
}
function healBarricade(barricade) {
    if (barricade.hp >= barricade.maxHp || coins < BARRICADE_HEAL_COST) return false;
    coins -= BARRICADE_HEAL_COST;
    barricade.hp = Math.min(barricade.hp + 10, barricade.maxHp); 
    return true;
}
function getBarricadeSellPrice(barricade) {
    const totalSpent = BARRICADE_COST + (barricade.level - 1) * BARRICADE_UPGRADE_COST;
    return Math.floor(totalSpent / 2); 
}
function sellBarricade(barricade) {
    const refund = getBarricadeSellPrice(barricade);
    coins += refund;
    barricades.splice(barricades.indexOf(barricade), 1);
    selectedBarricade = null;
}
function createNormalTower(x, y) { return { x, y, range: 120, cooldown: 0, stunned: 0, level: 1, damage: 20 }; }
function createSniperTower(x, y) { return { x, y, range: 240, cooldown: 0, level: 1, damage: 20 }; }
function getUpgradeCost(tower) {
    const isSniper = snipers.includes(tower);
    return (tower.level < 3) ? (isSniper ? 50 : 25) : null;
}
function upgradeTower(tower) {
    const cost = getUpgradeCost(tower);
    if (!cost || coins < cost) return false;
    coins -= cost;
    tower.level++;
    tower.range *= 1.15; 
    tower.damage += 10; 
    return true;
}
function getSellPrice(tower) {
    const isSniper = snipers.includes(tower);
    const baseCost = isSniper ? 100 : 50;
    const upgradeCost = isSniper ? 50 : 25;
    const totalSpent = baseCost + (tower.level - 1) * upgradeCost;
    return Math.floor(totalSpent / 2); 
}
function sellTower(tower) {
    const refund = getSellPrice(tower);
    coins += refund;
    const isSniper = snipers.includes(tower);
    if (isSniper) {
        snipers.splice(snipers.indexOf(tower), 1);
    } else {
        towers.splice(towers.indexOf(tower), 1);
    }
    selectedTower = null;
}


// --- –ö–ù–û–ü–ö–ò HTML ---
document.getElementById("startGame").onclick = () => {
¬† if(!gameStarted){ 
        gameStarted=true; 
        currentWaveIndex=1; 
        spawnWaveSequence(currentWaveIndex); 
    }
};
document.getElementById("restartGame").onclick = () => location.reload();

// üêõ –í–ò–ü–†–ê–í–õ–ï–ù–ê –õ–û–ì–Ü–ö–ê: –ü–µ—Ä–µ—Ö—ñ–¥ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ—ó —Ö–≤–∏–ª—ñ
document.getElementById("advanceWave").onclick = () => {
    if (!gameStarted || currentWaveIndex >= 10 || isSpawning) return;

    currentWaveIndex++;
    spawnWaveSequence(currentWaveIndex); 
};

document.getElementById("buyTower").onclick = () => { 
    if(coins>=50){ buyingTower=true; buyingSniper=false; buyingBarricade=false; selectedTower=null; selectedBarricade=null; } 
};
document.getElementById("buySniperTower").onclick = () => { 
    if(coins>=100){ buyingSniper=true; buyingTower=false; buyingBarricade=false; selectedTower=null; selectedBarricade=null; } 
};
document.getElementById("buyBarricade").onclick = () => { 
    if(coins>=BARRICADE_COST){ buyingBarricade=true; buyingTower=false; buyingSniper=false; selectedTower=null; selectedBarricade=null; } 
};


// ‚ùå –ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –¥–æ—Ä—ñ–∂–∫—É (–ë–µ–∑ –∑–º—ñ–Ω)
function isOnPath(x,y){
¬† for(let i=0;i<path.length-1;i++){
¬† ¬† const a=path[i], b=path[i+1];
¬† ¬† const dx=b.x-a.x, dy=b.y-a.y;
¬† ¬† const len=Math.hypot(dx,dy);
¬† ¬† const t=((x-a.x)*dx+(y-a.y)*dy)/(len*len);
¬† ¬† if(t<0||t>1) continue;
¬† ¬† const px=a.x+t*dx, py=a.y+t*dy;
¬† ¬† if(Math.hypot(x-px,y-py)<pathWidth/2) return true;
¬† }
¬† return false;
}

// üñ± –ö–ª—ñ–∫ –Ω–∞ –∫–∞–Ω–≤–∞—Å (–ë–µ–∑ –∑–º—ñ–Ω, –ª–æ–≥—ñ–∫–∞ –∫–µ—Ä—É–≤–∞–Ω–Ω—è –≤–µ–∂–∞–º–∏ –∫–æ—Ä–µ–∫—Ç–Ω–∞)
canvas.addEventListener("click", e => {
¬† const r = canvas.getBoundingClientRect();
¬† const x = e.clientX - r.left;
¬† const y = e.clientY - r.top;

    let entityClicked = false;

    // 1. –ü–ï–†–ï–í–Ü–†–ö–ê –ö–õ–Ü–ö–£ –ù–ê –ö–ù–û–ü–ö–ò –í–ï–ñ–Ü
    let clickedTower = [...towers, ...snipers].find(t => {
        const s = BUTTON_SIZE / 2;
        const sellX = t.x + BUTTON_SELL_OFFSET_X;
        const sellY = t.y + BUTTON_OFFSET_Y;
        const upgradeX = t.x + BUTTON_UPGRADE_OFFSET_X;
        const upgradeY = t.y + BUTTON_OFFSET_Y;
        
        if ((x >= sellX - s && x <= sellX + s && y >= sellY - s && y <= sellY + s) ||
            (x >= upgradeX - s && x <= upgradeX + s && y >= upgradeY - s && y <= upgradeY + s)) return true;
        
        if (Math.hypot(t.x - x, t.y - y) < 15) return true;
        
        return false;
    });

    if (clickedTower) {
        selectedTower = clickedTower;
        selectedBarricade = null; 
        entityClicked = true;

        const sellX = selectedTower.x + BUTTON_SELL_OFFSET_X;
        const sellY = selectedTower.y + BUTTON_OFFSET_Y;
        const upgradeX = selectedTower.x + BUTTON_UPGRADE_OFFSET_X;
        const upgradeY = selectedTower.y + BUTTON_OFFSET_Y;
        const s = BUTTON_SIZE / 2;

        if(x >= sellX - s && x <= sellX + s && y >= sellY - s && y <= sellY + s){ sellTower(selectedTower); return; }
        if(x >= upgradeX - s && x <= upgradeX + s && y >= upgradeY - s && y <= upgradeY + s){ upgradeTower(selectedTower); return; }
    }

    // 2. –ü–ï–†–ï–í–Ü–†–ö–ê –ö–õ–Ü–ö–£ –ù–ê –ö–ù–û–ü–ö–ò –ë–ê–†–ò–ö–ê–î–ò
    let clickedBarricade = barricades.find(b => {
        const s = BUTTON_SIZE / 2;
        const sellX = b.x + BUTTON_SELL_OFFSET_X;
        const sellY = b.y + BUTTON_OFFSET_Y;
        const upgradeX = b.x + BUTTON_UPGRADE_OFFSET_X;
        const upgradeY = b.y + BUTTON_OFFSET_Y;
        const healX = b.x + BUTTON_HEAL_OFFSET_X;
        const healY = b.y + BUTTON_OFFSET_Y;

        if ((x >= sellX - s && x <= sellX + s && y >= sellY - s && y <= sellY + s) ||
            (x >= upgradeX - s && x <= upgradeX + s && y >= upgradeY - s && y <= upgradeY + s) ||
            (x >= healX - s && x <= healX + s && y >= healY - s && y <= healY + s)) return true;

        if (Math.hypot(b.x - x, b.y - y) < 15) return true;

        return false;
    });

    if (clickedBarricade) {
        selectedBarricade = clickedBarricade;
        selectedTower = null; 
        entityClicked = true;

        const sellX = selectedBarricade.x + BUTTON_SELL_OFFSET_X;
        const sellY = selectedBarricade.y + BUTTON_OFFSET_Y;
        const upgradeX = selectedBarricade.x + BUTTON_UPGRADE_OFFSET_X;
        const upgradeY = selectedBarricade.y + BUTTON_OFFSET_Y;
        const healX = selectedBarricade.x + BUTTON_HEAL_OFFSET_X;
        const healY = selectedBarricade.y + BUTTON_OFFSET_Y;
        const s = BUTTON_SIZE / 2;

        if(x >= sellX - s && x <= sellX + s && y >= sellY - s && y <= sellY + s){ sellBarricade(selectedBarricade); return; }
        if(x >= upgradeX - s && x <= upgradeX + s && y >= upgradeY - s && y <= upgradeY + s){ upgradeBarricade(selectedBarricade); return; }
        if(x >= healX - s && x <= healX + s && y >= healY - s && y <= healY + s){ healBarricade(selectedBarricade); return; }
    }

    if (!entityClicked) {
        selectedTower = null;
        selectedBarricade = null;
    }

¬† // 3. –ö–£–ü–Ü–í–õ–Ø –¢–ê –†–û–ó–ú–Ü–©–ï–ù–ù–Ø 
  if(buyingBarricade && isOnPath(x,y)){
      barricades.push(createBarricade(x, y));
      coins -= BARRICADE_COST;
      buyingBarricade = false;
  }
  else if (!isOnPath(x,y)){
      if(buyingTower){ 
  ¬† ¬† ¬† ¬† towers.push(createNormalTower(x, y)); 
  ¬† ¬† ¬† ¬† coins-=50; 
  ¬† ¬† ¬† ¬† buyingTower=false; 
  ¬† }
  ¬† else if(buyingSniper){ 
  ¬† ¬† ¬† ¬† snipers.push(createSniperTower(x, y)); 
  ¬† ¬† ¬† ¬† coins-=100; 
  ¬† ¬† ¬† ¬† buyingSniper=false; 
  ¬† }
  }
});

// üñ± –û–±—Ä–æ–±–Ω–∏–∫ —Ä—É—Ö—É –º–∏—à—ñ (–ë–µ–∑ –∑–º—ñ–Ω)
canvas.addEventListener("mousemove", e => {
    const r = canvas.getBoundingClientRect();
    const x = e.clientX - r.left;
    const y = e.clientY - r.top;

    hoveredTower = null;
    hoveredBarricade = null;
    
    const allEntities = [...towers, ...snipers, ...barricades];
    const entityUnderMouse = allEntities.find(t => Math.hypot(t.x - x, t.y - y) < 15);
    
    if (entityUnderMouse) {
        if(towers.includes(entityUnderMouse) || snipers.includes(entityUnderMouse)) {
            hoveredTower = entityUnderMouse;
        } else {
            hoveredBarricade = entityUnderMouse;
        }
        canvas.style.cursor = 'pointer'; 
    } else {
        canvas.style.cursor = 'default';
    }
});


// ‚è± –ó–∞—Ç—Ä–∏–º–∫–∞ (–ë–µ–∑ –∑–º—ñ–Ω)
function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }

// üåä –§—É–Ω–∫—Ü—ñ—è —Å–ø–∞–≤–Ω—É –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó —Ö–≤–∏–ª—ñ
async function spawnWave(waveNum){
    if (isSpawning) return; // –Ø–∫—â–æ —Å–ø–∞–≤–Ω –≤–∂–µ –π–¥–µ, –±–ª–æ–∫—É—î–º–æ –ø–æ–≤—Ç–æ—Ä–Ω–∏–π –∑–∞–ø—É—Å–∫
    
    isSpawning = true;
    advanceWaveButton.disabled = true; // –ë–ª–æ–∫—É—î–º–æ –∫–Ω–æ–ø–∫—É

    const incr = mode==="normal"?1:2;
¬† ¬† const total = waveNum * incr;
¬† ¬† const hpBase = mode==="normal"?50:50*0.75;
¬† 
    // –ó–≤–∏—á–∞–π–Ω—ñ –≤–æ—Ä–æ–≥–∏
¬† ¬† for(let i=0;i<total;i++){
¬† ¬† ¬† ¬† enemies.push({x:path[0].x,y:path[0].y,hp:hpBase+waveNum*30,maxHp:hpBase+waveNum*30,speed:1,point:0});
¬† ¬† ¬† ¬† await sleep(400);
¬† ¬† }
¬† 
    // –ë–æ—Å–∏ –Ω–∞ 10-–π —Ö–≤–∏–ª—ñ
¬† ¬† if(waveNum===10){
¬† ¬† ¬† ¬† const numBoss = mode==="normal"?1:2;
¬† ¬† ¬† ¬† for(let i=0;i<numBoss;i++){
¬† ¬† ¬† ¬† ¬† ¬† const boss={x:path[0].x,y:path[0].y,hp:500,maxHp:500,speed:0.7,point:0,lastAttack:0};
¬† ¬† ¬† ¬† ¬† ¬† enemies.push(boss); bosses.push(boss);
¬† ¬† ¬† ¬† }
¬† ¬† }
    
    isSpawning = false;
    advanceWaveButton.disabled = false; // –†–æ–∑–±–ª–æ–∫–æ–≤—É—î–º–æ –∫–Ω–æ–ø–∫—É
}

// üåä –ü–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å —Ö–≤–∏–ª—å (–∑ –æ–Ω–æ–≤–ª–µ–Ω–æ—é –ª–æ–≥—ñ–∫–æ—é)
async function spawnWaveSequence(waveNum){
    
    // –Ø–∫—â–æ –ø–æ—Ç–æ—á–Ω–∞ —Ö–≤–∏–ª—è, —è–∫—É –º–∏ –Ω–∞–º–∞–≥–∞—î–º–æ—Å—è –∑–∞–ø—É—Å—Ç–∏—Ç–∏, –≤–∂–µ —Å–ø–∞–≤–Ω–∏—Ç—å—Å—è, –ø—Ä–æ—Å—Ç–æ –≤–∏—Ö–æ–¥–∏–º–æ.
    if (isSpawning) {
        // –õ–æ–≥—ñ–∫–∞ —Ç—É—Ç –±—É–ª–∞ —Å–∫–ª–∞–¥–Ω–æ—é. –ù–∞—Ç–æ–º—ñ—Å—Ç—å, –º–∏ –ø—Ä–æ—Å—Ç–æ –∑–∞–ø—É—Å–∫–∞—î–º–æ —Å–ø–∞–≤–Ω, 
        // –∞ isSpawning –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ spawnWave –≥–∞—Ä–∞–Ω—Ç—É—î, —â–æ —Ü–∏–∫–ª –Ω–µ –ø–æ—á–Ω–µ—Ç—å—Å—è –¥–≤—ñ—á—ñ.
    }
    
    await spawnWave(waveNum);
    
    // –¶–µ –≤—ñ–¥—Å—Ç–µ–∂—É—î –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∏–π –ø–µ—Ä–µ—Ö—ñ–¥, –∫–æ–ª–∏ –≤—Å—ñ –≤–æ—Ä–æ–≥–∏ –∑–Ω–∏—â–µ–Ω—ñ
    const checkEnemiesAndAdvance = async () => {
        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –Ω–µ –Ω–∞—Ç–∏—Å–Ω—É–≤ –≥—Ä–∞–≤–µ—Ü—å –∫–Ω–æ–ø–∫—É (—è–∫—â–æ currentWaveIndex –±—ñ–ª—å—à–∏–π)
        if (currentWaveIndex > waveNum) return; 

        // –ß–µ–∫–∞—î–º–æ, –ø–æ–∫–∏ –≤–æ—Ä–æ–≥–∏ –∑ —Ü—ñ—î—ó —Ö–≤–∏–ª—ñ –±—É–¥—É—Ç—å –∑–Ω–∏—â–µ–Ω—ñ 
        while(enemies.length > 0) {
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –Ω–µ –Ω–∞—Ç–∏—Å–Ω—É–≤ –≥—Ä–∞–≤–µ—Ü—å –∫–Ω–æ–ø–∫—É –ø—ñ–¥ —á–∞—Å –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è
            if (currentWaveIndex > waveNum) return; 
            await sleep(100);
        }
        
        // –Ø–∫—â–æ —Ü–µ –±—É–ª–∞ –æ—Å—Ç–∞–Ω–Ω—è —Ö–≤–∏–ª—è, –ø–µ—Ä–µ–º–æ–≥–∞
        if (waveNum >= 10) {
            gameStarted = false; 
            alert("üéâ –í–Ü–¢–ê–Ñ–ú–û! –í–∏ —É—Å–ø—ñ—à–Ω–æ –∑–∞—Ö–∏—Å—Ç–∏–ª–∏ –±–∞–∑—É!");
            return;
        }

        // –Ø–∫—â–æ –≤—Å—ñ –≤–æ—Ä–æ–≥–∏ –∑–Ω–∏—â–µ–Ω—ñ —ñ –≥—Ä–∞–≤–µ—Ü—å –Ω–µ –ø–µ—Ä–µ–π—à–æ–≤ —Å–∞–º (currentWaveIndex –Ω–µ –∑–º—ñ–Ω–∏–≤—Å—è),
        // –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø–µ—Ä–µ—Ö–æ–¥–∏–º–æ –Ω–∞ –Ω–∞—Å—Ç—É–ø–Ω—É —Ö–≤–∏–ª—é
        if (currentWaveIndex === waveNum) {
            wave = waveNum; // –û–Ω–æ–≤–ª—é—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—Ö —Ö–≤–∏–ª—å
            currentWaveIndex++;
            spawnWaveSequence(currentWaveIndex);
        }
    };
    
    // –Ø–∫—â–æ –º–∏ —â–æ–π–Ω–æ –∑–∞–ø—É—Å—Ç–∏–ª–∏ —Ü—é —Ö–≤–∏–ª—é, –≤—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥—É
    if (currentWaveIndex === waveNum) {
        checkEnemiesAndAdvance();
    }
}

// üé® –ú–∞–ª—é–≤–∞–Ω–Ω—è —Ç–∞ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è —Å—Ç–∞–Ω—É –≥—Ä–∏ (–ë–µ–∑ –∑–º—ñ–Ω)
function drawPath(){
¬† ctx.strokeStyle="#555"; ctx.lineWidth=pathWidth; ctx.lineJoin="round";
¬† ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y);
¬† path.forEach(p=>ctx.lineTo(p.x,p.y)); ctx.stroke();
}
function drawButton(x, y, color, text, subtext = null) {
    const s = BUTTON_SIZE / 2;
    
    ctx.fillStyle = color;
    ctx.fillRect(x - s, y - s, BUTTON_SIZE, BUTTON_SIZE);
    
    ctx.fillStyle = "white";
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "center";
    ctx.fillText(text, x, y + 5);

    if (subtext !== null) {
        ctx.fillStyle = "yellow";
        ctx.font = "10px Arial";
        ctx.fillText(subtext, x, y + BUTTON_SIZE + 2);
    }
}

// üîÑ –ì–æ–ª–æ–≤–Ω–∏–π —Ü–∏–∫–ª
function update(){
¬† ctx.clearRect(0,0,canvas.width,canvas.height);
¬† drawPath();

    // ... (–õ–æ–≥—ñ–∫–∞ –º–∞–ª—é–≤–∞–Ω–Ω—è –±–∞—Ä–∏–∫–∞–¥, –≤–µ–∂, –≤–æ—Ä–æ–≥—ñ–≤ —ñ –∫—É–ª—å –±–µ–∑ –∑–º—ñ–Ω) ...
    
    // --- –ë–ê–†–ò–ö–ê–î–ò ---
    for(let i = barricades.length - 1; i >= 0; i--) {
        const b = barricades[i];
        
        ctx.fillStyle = "sandybrown";
        ctx.fillRect(b.x - 15, b.y - 15, 30, 30);
        ctx.strokeStyle = "brown";
        ctx.lineWidth = 2;
        ctx.strokeRect(b.x - 15, b.y - 15, 30, 30);
        
        ctx.fillStyle = "black"; ctx.fillRect(b.x-15, b.y-20, 30, 4);
        ctx.fillStyle = b.hp/b.maxHp > 0.5 ? "lime" : (b.hp/b.maxHp > 0.2 ? "orange" : "red");
        ctx.fillRect(b.x-15, b.y-20, 30 * (b.hp / b.maxHp), 4);
        
        if(b === selectedBarricade || b === hoveredBarricade) {
            ctx.strokeStyle = "yellow";
            ctx.strokeRect(b.x - 17, b.y - 17, 34, 34);

            ctx.fillStyle = "white";
            ctx.font = "bold 10px Arial";
            ctx.textAlign = "center";
            ctx.fillText(`Lvl ${b.level}`, b.x, b.y + 20);

            if(b === selectedBarricade) {
                const upgradeCost = getBarricadeUpgradeCost(b);
                const sellPrice = getBarricadeSellPrice(b);

                drawButton(b.x + BUTTON_SELL_OFFSET_X, b.y + BUTTON_OFFSET_Y, "red", "X", sellPrice);

                const healColor = coins >= BARRICADE_HEAL_COST && b.hp < b.maxHp ? "darkgreen" : "gray";
                const healSubtext = b.hp < b.maxHp ? BARRICADE_HEAL_COST : "FULL";
                drawButton(b.x + BUTTON_HEAL_OFFSET_X, b.y + BUTTON_OFFSET_Y, healColor, "‚ù§Ô∏è", healSubtext);
                
                if(upgradeCost !== null){
                    const upColor = coins >= upgradeCost ? "green" : "darkred";
                    drawButton(b.x + BUTTON_UPGRADE_OFFSET_X, b.y + BUTTON_OFFSET_Y, upColor, "‚¨Ü", upgradeCost);
                } else {
                    drawButton(b.x + BUTTON_UPGRADE_OFFSET_X, b.y + BUTTON_OFFSET_Y, "gray", "‚òÖ", "MAX");
                }
            }
        }
        
        if(b.hp <= 0) {
            barricades.splice(i, 1);
            if(selectedBarricade === b) selectedBarricade = null;
        }
    }


¬† // --- –í–ï–ñ–Ü ---
¬† towers.forEach(t=>{
¬† ¬† ctx.fillStyle=t.stunned>0?"gray":"cyan";
    if(t === selectedTower || t === hoveredTower) {
        ctx.strokeStyle = "rgba(0, 255, 255, 0.5)";
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = "white";
        ctx.font = "bold 10px Arial";
        ctx.textAlign = "center";
        ctx.fillText(`Lvl ${t.level}`, t.x, t.y + 20);
    }
¬† ¬† ctx.beginPath(); ctx.arc(t.x,t.y,10,0,Math.PI*2); ctx.fill();
¬† ¬† 
    if(t === selectedTower) {
        const upgradeCost = getUpgradeCost(t);
        const sellPrice = getSellPrice(t);

        drawButton(t.x + BUTTON_SELL_OFFSET_X, t.y + BUTTON_OFFSET_Y, "red", "X", sellPrice);

        if(upgradeCost !== null){
            drawButton(t.x + BUTTON_UPGRADE_OFFSET_X, t.y + BUTTON_OFFSET_Y, coins >= upgradeCost ? "green" : "darkred", "‚¨Ü", upgradeCost);
        } else {
            drawButton(t.x + BUTTON_UPGRADE_OFFSET_X, t.y + BUTTON_OFFSET_Y, "gray", "‚òÖ", "MAX");
        }
    }
    
¬† ¬† if(t.cooldown>0) t.cooldown--; if(t.stunned>0) t.stunned--;
¬† ¬† if(t.cooldown===0 && t.stunned===0){
¬† ¬† ¬† const target=enemies.find(e=>Math.hypot(e.x-t.x,e.y-t.y)<t.range);
¬† ¬† ¬† if(target){
          const damage = t.damage; 
¬† ¬† ¬† ¬† ¬† const d=Math.hypot(target.x-t.x,target.y-t.y);
¬† ¬† ¬† ¬† ¬† bullets.push({x:t.x,y:t.y,dx:(target.x-t.x)/d*4,dy:(target.y-t.y)/d*4,magnetic:false, damage: damage});
¬† ¬† ¬† ¬† ¬† t.cooldown=25;
¬† ¬† ¬† }
¬† ¬† }
¬† });

¬† // üéØ –°–Ω–∞–π–ø–µ—Ä—Å—å–∫—ñ
¬† snipers.forEach(s=>{
    if(s === selectedTower || s === hoveredTower) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.range, 0, Math.PI * 2);
        ctx.stroke();

        ctx.fillStyle = "white";
        ctx.font = "bold 10px Arial";
        ctx.textAlign = "center";
        ctx.fillText(`Lvl ${s.level}`, s.x, s.y + 20);
    }

¬† ¬† if(s.cooldown>0) s.cooldown--;
¬† ¬† else{
¬† ¬† ¬† const target=enemies.find(e=>Math.hypot(e.x-s.x,e.y-s.y)<s.range);
¬† ¬† ¬† if(target){ 
          const damage = s.damage;
          bullets.push({x:s.x,y:s.y,dx:0,dy:0,magnetic:true,target, damage: damage}); 
          s.cooldown=50; 
        }
¬† ¬† }
¬† ¬† ctx.fillStyle="white"; ctx.beginPath(); ctx.arc(s.x,s.y,12,0,Math.PI*2); ctx.fill();

    if(s === selectedTower) {
        const upgradeCost = getUpgradeCost(s);
        const sellPrice = getSellPrice(s);

        drawButton(s.x + BUTTON_SELL_OFFSET_X, s.y + BUTTON_OFFSET_Y, "red", "X", sellPrice);

        if(upgradeCost !== null){
            drawButton(s.x + BUTTON_UPGRADE_OFFSET_X, s.y + BUTTON_OFFSET_Y, coins >= upgradeCost ? "green" : "darkred", "‚¨Ü", upgradeCost);
        } else {
            drawButton(s.x + BUTTON_UPGRADE_OFFSET_X, s.y + BUTTON_OFFSET_Y, "gray", "‚òÖ", "MAX");
        }
    }
¬† });

¬† // üëæ –í–æ—Ä–æ–≥–∏ 
¬† for(let i=enemies.length-1;i>=0;i--){
¬† ¬† const e=enemies[i];
¬† ¬† const target=path[e.point+1];
    
    let isColliding = false;
    const hitBarricade = barricades.find(b => Math.hypot(e.x - b.x, e.y - b.y) < 25); 

    if (hitBarricade) {
        isColliding = true;
        const damage = bosses.includes(e) ? 100 : 15; 
        hitBarricade.hp -= damage;
        
        if (!bosses.includes(e)) {
            enemies.splice(i, 1);
            continue; 
        }
    }

    if (!isColliding) {
        if(target){
          const dx=target.x-e.x, dy=target.y-e.y, dist=Math.hypot(dx,dy);
          e.x+=dx/dist*e.speed; e.y+=dy/dist*e.speed; if(dist<2) e.point++;
        } else { 
          baseHP -= bosses.includes(e)?50:10; 
          enemies.splice(i,1); 
          if(baseHP<=0){ alert("üõë –ë–∞–∑–∞ –∑–Ω–∏—â–µ–Ω–∞!"); location.reload(); } 
        }
    }

¬† ¬† if(bosses.includes(e)){
¬† ¬† ¬† ctx.fillStyle="orange"; ctx.beginPath(); ctx.moveTo(e.x,e.y-15); ctx.lineTo(e.x-15,e.y+15); ctx.lineTo(e.x+15,e.y+15); ctx.closePath(); ctx.fill();
¬† ¬† ¬† if(Date.now()-e.lastAttack>1000 && towers.length>0){ towers[Math.floor(Math.random()*towers.length)].stunned=90; e.lastAttack=Date.now(); }
¬† ¬† } else { ctx.fillStyle="red"; ctx.fillRect(e.x-10,e.y-10,20,20); }

¬† ¬† ctx.fillStyle="black"; ctx.fillRect(e.x-12,e.y-16,24,4);
¬† ¬† ctx.fillStyle="lime"; ctx.fillRect(e.x-12,e.y-16,24*(e.hp/e.maxHp),4);
¬† }

¬† // üî´ –ö—É–ª—ñ (–±–µ–∑ –∑–º—ñ–Ω)
¬† for(let bi=bullets.length-1;bi>=0;bi--){
¬† ¬† const b=bullets[bi];
    
¬† ¬† if(b.magnetic && b.target){
        if(enemies.includes(b.target)){
            const dx=b.target.x-b.x, dy=b.target.y-b.y;
            const dist=Math.hypot(dx,dy);
            b.dx=dx/dist*6; b.dy=dy/dist*6;
        } else {
            bullets.splice(bi,1);
            continue; 
        }
¬† ¬† }
¬† ¬† b.x+=b.dx; b.y+=b.dy;
¬† ¬† ctx.fillStyle="yellow"; ctx.fillRect(b.x,b.y,4,4);

¬† ¬† for(let ei=enemies.length-1;ei>=0;ei--){
¬† ¬† ¬† const e=enemies[ei];
¬† ¬† ¬† if(Math.abs(b.x-e.x)<10 && Math.abs(b.y-e.y)<10){
¬† ¬† ¬† ¬† ¬† e.hp-= (b.damage || 20); 
          bullets.splice(bi,1);
          
¬† ¬† ¬† ¬† ¬† if(e.hp<=0){
¬† ¬† ¬† ¬† ¬† ¬† const isBoss=bosses.includes(e);
¬† ¬† ¬† ¬† ¬† ¬† if(isBoss){ bosses.splice(bosses.indexOf(e),1); coins+=10; }
¬† ¬† ¬† ¬† ¬† ¬† else coins+=(mode==="hard"?5:10);
¬† ¬† ¬† ¬† ¬† ¬† enemies.splice(ei,1);
¬† ¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† ¬† break;
¬† ¬† ¬† }
¬† ¬† }
¬† }

¬† document.getElementById("coins").innerText=coins;
¬† document.getElementById("wave").innerText=Math.min(currentWaveIndex,10); 
¬† if(!document.getElementById("baseHP")){
¬† ¬† const p=document.createElement("p"); p.id="baseHP"; p.innerText="–ë–∞–∑–∞ HP: "+baseHP; document.body.insertBefore(p,canvas);
¬† } else document.getElementById("baseHP").innerText="–ë–∞–∑–∞ HP: "+baseHP;

¬† requestAnimationFrame(update);
}

update();
</script>


</body>
</html>